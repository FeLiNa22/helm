# Password Persistence Implementation Summary

## Problem Statement

Autogenerated passwords for databases and other services were being regenerated on every chart release/upgrade. This caused issues with ArgoCD auto-deployment scenarios where:

1. ArgoCD detects a new chart version
2. Triggers an automatic upgrade
3. Helm regenerates random passwords
4. Stored in Kubernetes secrets
5. Application loses access to the database (password mismatch)

## Root Cause

Charts using Bitnami subcharts (PostgreSQL, Redis, MinIO) with empty or hardcoded passwords in `values.yaml` would trigger the subchart's password generation logic on every upgrade, creating new random passwords instead of preserving existing ones.

## Solution

Implemented password persistence using Helm's `lookup` function to check for existing secrets and reuse their values. This prevents password regeneration on chart upgrades.

### Charts Modified

1. **outline** (v1.1.4 → v1.2.0)
   - PostgreSQL, Redis, MinIO password persistence
   
2. **penpot** (v1.1.4 → v1.2.0)
   - PostgreSQL, Redis password persistence

### Charts Already Correct

- **frigate**: Already uses lookup for CNPG PostgreSQL
- **immich**: Already uses lookup for CNPG PostgreSQL and standalone mode
- **nextcloud**: Already uses lookup for CNPG PostgreSQL

## Implementation Details

### Secret Template Pattern

Created `000-secrets.yaml` templates in each chart that:

1. Check if `existingSecret` is configured (skip if user provides their own)
2. Generate deterministic secret name: `<release-name>-<service>-auth`
3. Use `lookup` function to check if secret already exists in the cluster
4. If exists: Extract and decode the existing password
5. If not exists: Generate new random 32-character password
6. Create/update the secret with the password

Example for PostgreSQL:
```yaml
{{- if and .Values.global.postgresqlEnabled (not .Values.postgresql.auth.existingSecret) }}
{{- $secretName := printf "%s-postgresql-auth" .Release.Name }}
{{- $existingSecret := lookup "v1" "Secret" .Release.Namespace $secretName }}
{{- $password := "" }}
{{- if $existingSecret }}
{{- $password = index $existingSecret.data "password" | b64dec }}
{{- else }}
{{- $password = .Values.postgresql.auth.password | default (randAlphaNum 32) }}
{{- end }}
# ... create secret with $password
{{- end }}
```

### Secret Naming Convention

- PostgreSQL: `<release-name>-postgresql-auth`
  - Keys: `password`, `postgres-password`
- Redis: `<release-name>-redis-auth`
  - Key: `redis-password`
- MinIO: `<release-name>-minio-auth`
  - Keys: `root-user`, `root-password`

### User Configuration

Users must configure the subcharts to use these auto-generated secrets:

**Option 1: Using --set flags**
```bash
helm install my-app raulpatel/outline \
  --set postgresql.auth.existingSecret=my-app-postgresql-auth \
  --set redis.auth.enabled=true \
  --set redis.auth.existingSecret=my-app-redis-auth \
  --set minio.auth.existingSecret=my-app-minio-auth
```

**Option 2: Using values file**
```yaml
postgresql:
  auth:
    existingSecret: "my-app-postgresql-auth"
redis:
  auth:
    enabled: true
    existingSecret: "my-app-redis-auth"
minio:
  auth:
    existingSecret: "my-app-minio-auth"
```

## Benefits

1. **Password Persistence**: Passwords are preserved across chart upgrades
2. **ArgoCD Compatible**: Automatic upgrades don't break authentication
3. **Backward Compatible**: Existing deployments can opt-in by configuration
4. **Secure by Default**: Uses cryptographically strong random passwords (32 chars)
5. **Flexible**: Users can still provide their own secrets if preferred

## Testing

- ✅ Helm lint passes for both charts
- ✅ Template syntax validated
- ✅ Example values files provided
- ✅ README documentation comprehensive
- ✅ Code review feedback addressed

## Migration Guide

### For Existing Deployments

If you have an existing deployment with Bitnami-generated passwords:

1. Extract current passwords:
   ```bash
   kubectl get secret <release-name>-postgresql -o jsonpath='{.data.password}' | base64 -d
   ```

2. Create the persistence secret manually:
   ```bash
   kubectl create secret generic <release-name>-postgresql-auth \
     --from-literal=password=<extracted-password> \
     --from-literal=postgres-password=<extracted-postgres-password>
   ```

3. Upgrade with existingSecret configured:
   ```bash
   helm upgrade <release-name> raulpatel/outline \
     --set postgresql.auth.existingSecret=<release-name>-postgresql-auth
   ```

### For New Deployments

Simply install with the existingSecret configured and let the chart handle password generation:

```bash
helm install my-app raulpatel/outline -f values-with-persistence.yaml
```

## Files Changed

### Outline Chart
- `charts/outline/templates/000-secrets.yaml` (new)
- `charts/outline/values.yaml` (updated)
- `charts/outline/README.md` (updated)
- `charts/outline/Chart.yaml` (version bump)
- `charts/outline/values-password-persistence-example.yaml` (new)

### Penpot Chart
- `charts/penpot/templates/000-secrets.yaml` (new)
- `charts/penpot/values.yaml` (updated)
- `charts/penpot/README.md` (updated)
- `charts/penpot/Chart.yaml` (version bump)
- `charts/penpot/values-password-persistence-example.yaml` (new)

## Security Considerations

1. **Random Password Strength**: 32-character alphanumeric passwords provide 192 bits of entropy
2. **Secret Storage**: Passwords stored in Kubernetes secrets (base64 encoded, encrypted at rest if configured)
3. **No Hardcoded Defaults**: No default passwords in the charts
4. **Lookup Function Safety**: The lookup function only reads from the same namespace
5. **Minimal Permissions**: Helm only needs read access to existing secrets, write to create new ones

## Future Improvements

Potential enhancements for future versions:

1. Auto-configure `existingSecret` using a helper template (requires Helm 4.0+ features)
2. Add password rotation capabilities with annotation triggers
3. Support for external secret managers (Vault, AWS Secrets Manager, etc.)
4. Add validation webhooks to prevent accidental secret deletion
